// src-tauri/src/linker.rs
use tauri::AppHandle;
use std::{thread, time};
use enigo::{Enigo, MouseControllable, MouseButton}; 
use base64::{Engine as _, engine::general_purpose::STANDARD};
use std::io::Cursor;
use xcap::Window;
use image::{DynamicImage, Rgba, GenericImageView}; // 引入 GenericImageView
use std::cmp;

#[derive(serde::Serialize, Clone)]
pub struct WindowInfo {
    id: u32,
    name: String,
    x: i32,
    y: i32,
    width: u32,
    height: u32,
    is_minimized: bool,
}

#[derive(serde::Serialize)]
pub struct CaptureResult {
    image_base64: String,
    width: u32,
    height: u32,
}

#[tauri::command]
pub async fn list_windows() -> Result<Vec<WindowInfo>, String> {
    let windows = Window::all().map_err(|e| e.to_string())?;
    let mut result = Vec::new();
    for window in windows {
        result.push(WindowInfo {
            id: window.id(),
            name: window.title().to_string(),
            x: window.x(),
            y: window.y(),
            width: window.width(),
            height: window.height(),
            is_minimized: window.is_minimized(),
        });
    }
    Ok(result)
}

#[tauri::command]
pub async fn get_window_info(window_id: u32) -> Result<WindowInfo, String> {
    let windows = Window::all().map_err(|e| e.to_string())?;
    for window in windows {
        if window.id() == window_id {
            return Ok(WindowInfo {
                id: window.id(),
                name: window.title().to_string(),
                x: window.x(),
                y: window.y(),
                width: window.width(),
                height: window.height(),
                is_minimized: window.is_minimized(),
            });
        }
    }
    Err("Window not found".to_string())
}

// 原版截图函数（保留用于UI显示，如果需要高清图的话）
#[tauri::command]
pub async fn capture_window(window_id: u32) -> Result<CaptureResult, String> {
    let windows = Window::all().map_err(|e| e.to_string())?;
    for window in windows {
        if window.id() == window_id {
            let image = window.capture_image().map_err(|e| e.to_string())?;
            
            // 保持原逻辑：转为白底 RGB 避免透明问题
            let width = image.width();
            let height = image.height();
            let mut rgb_image = image::ImageBuffer::from_pixel(width, height, Rgba([255, 255, 255, 255]));
            image::imageops::overlay(&mut rgb_image, &image, 0, 0);
            let dynamic_image = DynamicImage::ImageRgba8(rgb_image);
            
            let mut buffer = Vec::new();
            let mut cursor = Cursor::new(&mut buffer);
            // 这里依然用 PNG，保证UI显示清晰
            dynamic_image.write_to(&mut cursor, image::ImageFormat::Png).map_err(|e| e.to_string())?;
            
            let base64_string = STANDARD.encode(&buffer);
            return Ok(CaptureResult {
                image_base64: base64_string,
                width,
                height,
            });
        }
    }
    Err("Window not found".to_string())
}

// ★★★ 新增：AI专用极速截图接口 ★★★
#[tauri::command]
pub async fn capture_for_ai(window_id: u32) -> Result<CaptureResult, String> {
    let windows = Window::all().map_err(|e| e.to_string())?;
    for window in windows {
        if window.id() == window_id {
            // 1. 截图
            let image = window.capture_image().map_err(|e| e.to_string())?;
            
            // 2. ★核心加速：直接在 Rust 里缩放★
            // 缩放到 640x640 以内 (保持长宽比)，YOLO/ONNX 只需要这么大
            // FilterType::Triangle 速度快且质量足够识别棋子
            let scaled = image.resize(640, 640, image::imageops::FilterType::Triangle);
            
            let width = scaled.width();
            let height = scaled.height();

            // 3. 处理透明背景 (Overlay on white)
            // 因为 JPEG 不支持透明，且透明背景会干扰 AI
            let mut rgb_image = image::ImageBuffer::from_pixel(width, height, Rgba([255, 255, 255, 255]));
            image::imageops::overlay(&mut rgb_image, &scaled, 0, 0);
            let final_image = DynamicImage::ImageRgba8(rgb_image);

            // 4. ★核心加速：转为 JPEG★
            // JPEG 编码比 PNG 快得多，且 Base64 字符串体积减少 80% 以上
            let mut buffer = Vec::new();
            let mut cursor = Cursor::new(&mut buffer);
            // 质量 75 足够 AI 识别
            final_image.write_to(&mut cursor, image::ImageFormat::Jpeg(75)).map_err(|e| e.to_string())?;
            
            let base64_string = STANDARD.encode(&buffer);
            
            // 返回缩放后的宽高，前端需要用这个比例还原坐标
            return Ok(CaptureResult {
                image_base64: base64_string,
                width,
                height,
            });
        }
    }
    Err("Window not found".to_string())
}


#[tauri::command]
pub async fn capture_screen(display_id: usize) -> Result<CaptureResult, String> {
    let screens = xcap::Monitor::all().map_err(|e| e.to_string())?;
    if display_id >= screens.len() {
        return Err("Display ID out of range".to_string());
    }
    let screen = &screens[display_id];
    let image = screen.capture_image().map_err(|e| e.to_string())?;
    
    let width = image.width();
    let height = image.height();
    let mut buffer = Vec::new();
    let mut cursor = Cursor::new(&mut buffer);
    image.write_to(&mut cursor, image::ImageFormat::Png).map_err(|e| e.to_string())?;
    
    Ok(CaptureResult {
        image_base64: STANDARD.encode(&buffer),
        width,
        height,
    })
}

#[tauri::command]
pub async fn capture_region(x: i32, y: i32, width: u32, height: u32) -> Result<CaptureResult, String> {
    let screens = xcap::Monitor::all().map_err(|e| e.to_string())?;
    if screens.is_empty() { return Err("No screens found".to_string()); }
    
    let image = screens[0].capture_image().map_err(|e| e.to_string())?;
    let cropped = image::imageops::crop_imm(&image, x as u32, y as u32, width, height).to_image();
    
    let mut buffer = Vec::new();
    let mut cursor = Cursor::new(&mut buffer);
    cropped.write_to(&mut cursor, image::ImageFormat::Png).map_err(|e| e.to_string())?;
    
    Ok(CaptureResult {
        image_base64: STANDARD.encode(&buffer),
        width,
        height,
    })
}

#[tauri::command]
pub async fn simulate_move(
    from_x: i32,
    from_y: i32,
    to_x: i32,
    to_y: i32,
    click_delay_ms: u64,
    move_delay_ms: u64
) -> Result<(), String> {
    // 这里没变，只是为了调试信息更清晰加了点 log
    println!("[Rust Linker] 模拟移动: ({}, {}) -> ({}, {})", from_x, from_y, to_x, to_y);
    let mut enigo = Enigo::new();
    enigo.mouse_move_to(from_x, from_y);
    thread::sleep(time::Duration::from_millis(20)); // 稍微改快一点点
    enigo.mouse_down(MouseButton::Left);
    if click_delay_ms > 0 { thread::sleep(time::Duration::from_millis(click_delay_ms)); }
    enigo.mouse_up(MouseButton::Left);

    if move_delay_ms > 0 { thread::sleep(time::Duration::from_millis(move_delay_ms)); }

    enigo.mouse_move_to(to_x, to_y);
    thread::sleep(time::Duration::from_millis(20));
    enigo.mouse_down(MouseButton::Left);
    if click_delay_ms > 0 { thread::sleep(time::Duration::from_millis(click_delay_ms)); }
    enigo.mouse_up(MouseButton::Left);
    Ok(())
}

#[tauri::command]
pub async fn simulate_click(x: i32, y: i32, delay_ms: u64) -> Result<(), String> {
    let mut enigo = Enigo::new();
    enigo.mouse_move_to(x, y);
    thread::sleep(time::Duration::from_millis(20));
    enigo.mouse_down(MouseButton::Left);
    if delay_ms > 0 { thread::sleep(time::Duration::from_millis(delay_ms)); }
    enigo.mouse_up(MouseButton::Left);
    Ok(())
}
